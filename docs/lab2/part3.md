# 实验实现
!!! note "提示"
    这里，我们将对一些实现的细节做一定提醒，但是完整的流程需要自己把握，我们 **不会给出每一步实现步骤** 。因此，最重要的还是阅读[实验原理](../part2)内容，得出自己的解决方案，然后参考"实验实现"这部分的内容。

    值得注意的是，xv6的代码很值得参考，可以看看其他系统调用和功能是怎么实现的。同时，还可以使用 `printf` 或者 `gdb` 等方法查看具体的执行情况。此外，还可以阅读 xv6 指导书，看看背后的设计机理。
    
    如果在实现过程中遇到困难，可以 **先尝试回答[任务四](#4)** 提出的问题，它们或许可以帮助你更好地理解。

## 1. 任务一：进程信息收集

**具体要求：在exit系统调用当中寻找合适的输出时间点，在相应的函数内进行父子进程信息的打印。**

### 1.1 流程

首先切换分支：

- 参考[这个指南](../part1/#31)，切换到syscall分支并同步上游仓库；

在内核部分：

- 参考[exit系统调用工作流程](../part2/#3)，阅读`proc.c: exit(int)`相关源码，在合适的位置使用`exit_info`输出。
- 然后启动xv6，在shell输入 `exittest` ，要能满足[实验概述](../part1/#322)中提到的输出。

## 2. 任务二：wait系统调用的非阻塞选项实现

**具体要求：更改原有的wait系统调用，添加新参数，实现wait系统调用的非阻塞选项。**

### 2.1 流程

在用户部分：

- 由于我们已经将用户态的wait接口做好了更改，同学们无需更改用户部分代码。

在内核部分：

- 更改内核部分的wait接口定义（在`defs.h`中），以及相应的函数接口（`proc.c: wait(uint64)`）；
- 在`sysproc.c: sys_wait(void)`函数中获取用户态传入的新参数；
- 在`proc.c: wait(uint64, int)`中实现非阻塞逻辑。
- 然后启动xv6，在shell输入 `waittest` ，要能满足[实验概述](../part1/#33)中提到的输出。

## 3. 任务三：实现yield系统调用

**具体要求：实现一个新的系统调用yield，并且在调用该系统调用时，打印用户态PC值。**

### 3.1 流程 

在用户部分：

- 在`user.h`添加相关的系统调用声明；
- 在`usys.pl`文件中新增一个entry；
- 在`Makefile`的`UPROGS`变量中新增一个用户程序`_yieldtest`。

在内核部分：

- 在`syscall.h`中增加一个新的系统调用号，具体值你自己决定；
- 在`syscall.c`中增加一个extern函数声明，以及在`syscalls`数组中增加一项；
- 在`sysproc.c`中增加一个`sys_yield`函数，在该函数中：
    - 首先需要获取到用户上下文中保存的PC值，然后打印出来；
    - 然后将当前进程挂起，XV6内核态已经帮我们实现了一个`yield`函数了。


## 4. 任务四：回答问题

!!! question  "回答问题"
    

    (1) 阅读`kernel/syscall.c`，试解释函数 `syscall()` 如何根据系统调用号调用对应的系统调用处理函数（例如`sys_fork`）？`syscall()` 将具体系统调用的返回值存放在哪里？
    
    (2) 阅读`kernel/syscall.c`，哪些函数用于传递系统调用参数？试解释argraw()函数的含义。
    
    (3) 阅读`kernel/proc.c`和`proc.h`，进程控制块存储在哪个数组中？进程控制块中哪个成员指示了进程的状态？一共有哪些状态？

    (4) 在任务一当中，为什么子进程（4、5、6号进程）的输出之前会 **稳定的** 出现一个`$`符号？（提示：shell程序(`sh.c`)中什么时候打印出`$`符号？）  
    ![q4](part3.assets/q4.png)
    
    (5) 在任务三当中，我们提到测试时需要指定CPU的数量为1，因为如果CPU数量大于1的话，输出结果会出现乱码，这是为什么呢？（提示：多核心调度和单核心调度有什么区别？）

​      