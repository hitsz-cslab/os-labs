# 实验实现
!!! note "提示"
    这里，我们将对一些实现的细节做一定提醒，但是完整的流程需要自己把握，我们 **不会给出每一步实现步骤** 。因此，最重要的还是阅读[实验原理](../part2)内容，得出自己的解决方案，然后参考"实验实现"这部分的内容。

    值得注意的是，xv6的代码很值得参考，可以看看其他系统调用和功能是怎么实现的。同时，还可以使用 `printf` 或者 `gdb` 等方法查看具体的执行情况。此外，还可以阅读 xv6 指导书，看看背后的设计机理。
    
    如果在实现过程中遇到困难，可以 **先尝试回答任务三** 提出的问题，它们或许可以帮助你更好地理解。

## 1. 任务一：进程信息收集

**具体要求：在exit系统调用当中寻找合适的输出时间点，在相应的函数内进行父子进程信息的打印。**

### 1.1 流程

在用户部分：

- 参考[这个指南](../../tools/#31)，切换到syscall分支并同步上游仓库；
- 然后启动xv6，在shell输入 `exittest` ，你会看见[实验概述](../part1/#322)中提到的输出。

在内核部分：

- 参考[exit系统调用工作流程](../part2/#3)，阅读`proc.c: exit(int)`相关源码，在合适的位置使用printf输出。

## 2. 任务二：wait系统调用的非阻塞选项实现

**具体要求：更改原有的wait系统调用，添加新参数，实现wait系统调用的非阻塞选项。**

### 2.1 流程

在用户部分：

- 切至 `syscall` git分支；
- 由于我们已经将用户态的wait接口做好了更改，同学们只需要运行即可；
- 然后启动xv6，在shell输入 `waittest` ，你会看见[实验概述](../part1/#33)中提到的输出。

在内核部分：

- 更改内核部分的wait接口定义（在`defs.h`中），以及相应的函数接口（`proc.c: wait(uint64)`）；
- 在`sysproc.c: sys_wait(void)`函数中获取用户态传入的新参数；
- 在`proc.c: wait(uint64, int)`中实现非阻塞逻辑。

## 3. 任务三：实现yield系统调用

**具体要求：实现一个新的系统调用yield，并且在调用该系统调用时，打印用户态PC值。**

### 3.1 流程 

在用户部分：

- 在user.h添加相关的系统调用声明；
- 在usys.pl文件中新增一个entry。
- 在Makefile的UPROGS变量中新增一个用户程序`_yieldtest`

在内核部分：

- 在syscall.h中增加一个新的系统调用号，具体值你自己决定；
- 在sysproc.c中增加一个sys_yield函数，在该函数中：
  - 首先需要获取到用户上下文中保存的PC值，然后打印出来；
  - 然后将当前进程挂起，XV6内核态已经帮我们实现了一个yield函数了。


## 4. 任务四：回答问题

!!! question  "回答问题"
    

    (1) 阅读`kernel/syscall.c`，试解释函数 `syscall()` 如何根据系统调用号调用对应的系统调用处理函数（例如`sys_fork`）？`syscall()` 将具体系统调用的返回值存放在哪里？
    
    (2) 阅读`kernel/syscall.c`，哪些函数用于传递系统调用参数？试解释argraw()函数的含义。
    
    (3) 阅读`kernel/proc.c`和`proc.h`，进程控制块存储在哪个数组中？进程控制块中哪个成员指示了进程的状态？一共有哪些状态？

    (4)
    
    (5)

    (6) 在任务三当中，我们提到测试时需要指定CPU的数量为1，因为如果CPU数量大于1的话，输出结果会出现乱码，这是为什么呢？（提示：多核心调度和单核心调度有什么区别？）
    
    <!-- (4) 阅读`kernel/kalloc.c`，哪个结构体中的哪个成员可以指示空闲的内存页？Xv6中的一个页有多少字节？ -->
    
    <!-- (5) 阅读`kernel/vm.c`，试解释`copyout()`函数各个参数的含义。 -->


​      